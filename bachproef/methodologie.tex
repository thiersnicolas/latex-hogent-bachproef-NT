%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}%
\label{ch:methodologie}

\section{Inleiding}

Voor het analyseren van het performantieverschil tussen REST en gRPC is er voor beide technologi\"en een server nodig die een api aanbiedt dat geconsumeerd kan worden en
een client die deze server aanroept.
De tijdsduur tussen de start en einde van de request, m.a.w. tussen het aanroepen van het api door de client
tot het moment waarop alle gevraagde data bij de client toegekomen is, vormt het belangrijkste vergelijkingspunt.
Er zullen verschillende datasets verstuurd worden opdat kan worden ge\"evalueerd in hoeverre deze grootte een impact heeft op de performantie.
Aangezien er in de praktijk meestal een limiet wordt gezet op de toegelaten reponse body size wordt ook het effect van paginatie in beshouwing genomen.
Voor REST zal het veelgebruikte JSON als serialisatie formaat dienen. Hiernaast zal, met als doel de performantie te optimaliseren,
tevens naar een gecompresseerd formaat gekeken worden. gRPC zonder compressie lijkt in de praktijk weinig zinvol te zijn waardoor het geen onderdeel
zal uitmaken van het vergelijkend onderzoek. Tot slot zal getracht worden de performantie van gRPC middels een Stream vast te leggen.\\

\section{Opzet}

Zowel de server als client applicatie worden, in aparte modules, in één groot Gradle project geplaatst.
Gradle is een build automation tool dat ook dependency management verzorgt. Deze twee modules kunnen apart gebuild en eventueel gedeployed worden.\newline
~\autocite{Gradle}

\paragraph{Server applicatie}

Voor alle stadia van het onderzoek wordt er gebruik gemaakt van een java server applicatie die zowel een REST en gRPC API aanbiedt.
In dit geval zal het gaan om API's die toelaten een lijst van fictieve personen op te vragen. Het aantal personen dat verzonden wordt moet door de client worden aangegeven.
De eerste keer dat een lijst wordt opgevraagd wordt de data gegenereerd en opgeslagen in het geheugen van de applicatie volgens het aantal gevraagde objecten.
Op deze wijze is er zekerheid dat het genereren van de data slechts op de 1e maal dat het api wordt aangereoepen een vertragend effect zal hebben.
Een persoon instantie bevat 5 variabelen die tijdens het genereren van de data m.b.v.\ RandomStringUtils~\parencite{RandomStringUtils}
en RandomDataGenerator~\parencite{RandomDataGenerator} van Apache Commons opgevuld worden met willekeurige tekst of cijfers naargelang het type van variabele.
Voor elk gevraagd aantal zal de eerste request als opwarming dienen en niet worden gebruikt worden als vergelijking.
De java applicatie is ontwikkeld met behulp van het Quarkus framework.
Quarkus biedt zowel ondersteuning voor REST als voor gRPC.\newline
~\autocite{quarkusAbout}\\

Voor de REST api maakt Quarkus gebruik van RESTEasy, een Jakarta REST-implementatie. Jakarta REST is een REST API-standaard voor Java.
Het serialisatieproces naar JSON gebeurd d.m.v Jackson en gebeurd automatisch door het Quarkus framework.
Het framework voorziet ook in de mogelijkheid om de data te comprimeren voor ze te verzenden.
Het serialiseringsproces naar JSON door Jackson, de compressie en decompressie voor REST alsook het serialisering- en compressieproces bij gRPC zullen telkens opnieuw moeten gebeuren.
Deze processen moeten immers ook deel uitmaken van het vergelijkend onderzoek.
Het REST api wordt voorzien in de klasse People5Resource, boven de definitie van deze klasse wordt een @Path annotatie voorzien waarbij
het eerste deel van de url, ''/people5'', die voor alle endpoints gelijk is, als value wordt meegegeven.
Er worden 3 endpoints aangeboden in dit REST API die zullen aangeroepen worden tijdens de testen. Een GET endpoint ''/people5/\{amount\}'' waarmee een gespecifieerde hoeveelheid
personen kan opgevraagd worden. Dit komt overeen met de methode people5 welke voorzien ook voorzien wordt van een @Path annotatie
die het specifiek voor dat endpoint nodige deel van de url meekrijgt als value nl. ''/\{amount\}''. Amount is hier een path variable. In de variabelen van
de methode moet amount ook geannoteerd worden met @PathParam met hetzelfde value als in de url om het framework deze te laten doorgeven.
Dankzij deze path variable worden bijvoorbeeld 5 personen opgevraagd via een GET request door middel van een variabele in de URI te voorzien b.v.
people/5 of people/5/compressed.
Een @GET annotatie wijst aan welke HTTP method naar deze methode geleid moet worden. @Produces zegt welk media type dit endpoint zal retourneren, hier is dat application JSON.
Quarkus zal deze serialisatie automatisch verzorgen. Tot slot annoteren we de method met @Uncompressed om zeker te zijn dat Quarkus hier geen compressie zal toepassen.
Een tweede GET endpoint ''/people5/\{amount\}/compressed'' met dezelfde werking, maar waarbij de data door Quarkus wordt gecomprimeerd alvorens ze wordt verzonden,
wordt met de people5compressed methode gedefinie\"rd. Hier worden dezelfde annotatie geplaatst als het eerdere endpoint behalve de @Uncompressed welke vervangen
wordt door @Compressed zodat Quarkus compressie toepast en ook wordt @Provides weggelaten.
Voor beiden wordt de hoeveelheid aangegeven met een path variabele welke in het URI wordt geplaatst. Boven elke methode, die overeenkomen met een endpoint,
wordt nogmaals een @Path annotatie voorzien die het specifiek voor dat endpoint nodige deel van de url meekrijgt als value.
Via het derde endpoint kan de opgeslagen data, ook cache genaamd, worden leeggemaakt. Dit endpoint kan aangeroepen worden via een POST request naar
de URI van de applicatie aangevuld met ''/people5/cleardata''. Hier worden ook weer een @Path annotatie voorzien met ''/cleardata'', een @POST annotatie om de HTTP method te
specifi\"ren en nog een @Produces met application JSON voor het data formaat aan te geven. Indien de cache wordt leeggemaakt is dit voor beide beschikbare formaten van toepassing.
Dit endpoint geeft een lijst van de eerder opgevraagde hoeveelheden die nu in de cache zitten terug.
Na het leegmaken van de cache zou dit dus steeds een lege lijst moeten zijn.\newline
~\autocite{quarkusREST}\\
~\autocite{Jakarta}\\

Voor het gRPC api wordt gestart vanaf de Quarkus ''tutorial Getting Started With gRPC''~\parencite{quarkusgRPC}.
Bij gRPC moet er een bestand gemaakt worden, met .proto als extensie, waarin alle procedures, welke ter beschikking zijn, worden vastgelegd.
Op basis van dit bestand zal de protocol buffer compiler code genereren.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\linewidth]{protobestand}
    \caption{[.proto bestand].proto bestand}
\end{figure}

Het bestand start met aan te geven welke syntax gebruikt wordt, in dit geval is dat versie 3, de meest recente versie, van de protocol buffers.
Daarna volgen drie opties die specifek voor java applicaties dienen: ''java\_multiple\_files'', ''java\_package'' en ''java\_outer\_classname''.
java\_multiple\_files staat op true zodat er een apart .java bestand gemaakt wordt voor elke gegenereerde klasse in plaats
van één wrapper klass en in nested klasses daarvan alle andere klassen. Bij ''java\_package'' staat niet dezelfde package die in de rest van de applicatie gebruikt is
maar in een proto subpackage zoals aangegeven in de best practices.
Tot slot geeft de ''java\_outer\_classname'' optie aan dat People5GrpcProto moet gebruikt worden als naam voor de wrapper klasse van de service gedefineerd in dit .proto bestand.
Daaronder wordt aangegeven welke package wordt gebruikt voor de gegenereerde code. Dit wordt overschreven door de ''java\_package'' optie die eerder gedefineerd werd maar
in de protobuf Java tutorial~\parencite{protobufJava} wordt vermeld dat er steeds een package moet gedefineerd worden, zelfs bij het gebruik van de optie jav\_package, om naam collisie
te vermijden in de protocol buffer name space. Hierna volgt de effectieve beschrijving van het gRPC API startend met een service interface genaamd People5Grpc waarin
alle beschikbare functies worden gedefineerd. De functie ClearData werkt zoals het eerder beschreven gelijknamige REST endpoint en zorgt dat de cache wordt leeggemaakt.
Met de functie GetPeople kan er een lijst van persoon objecten opgevraagd worden met als waarbij de grootte overeenkomst met de opgegeven hoeveelheid.
Tot slot is er een GetPeopleStream functie die een stream van persoon objecten teruggeeft van het gevraagde aantal.
Na deze functies gedefineerd te hebben moeten de messages die ze ontvangen en verzenden omschreven worden.
ClearDataInput en SupportedAmountsInput zijn lege messages. Er moet steeds een message opgegeven worden voor het return value van een functie.
In plaats van een lege message te defini\"eren kan ook google.protobuf.Empty gebruikt worden, maar dan is het achteraf niet mogelijk om de bestaande functie
te wijzigen in die zin dat ze toch een niet lege message meegeeft. Door een message te beschrijven kunnen hier later nog variabelen aan toegevoegd worden.
Voor dit onderzoek zal dit waarschijnlijk niet nodig zijn maar er wordt toch geopteerd de best practices te respecteren.
SupportedAmounts bevat een lijst van integers, dit wordt aangegeven door het keyword repeated.
Net zoals bij het REST endpoint cleardata zou deze lijst steeds leeg moeten zijn gezien de cache juist werd leeggemaakt.
De message GrpcPeople5 bevat een lijst van GrpcPerson5 messages. GrpcPerson5 geeft het persoon object weer en definieert de 5 variabelen. Als laatste message is er nog
Amount dat als te ontvangen message dient voor de GetPeople en GetPeopleStream functies. Deze message omvat simpelweg een integer die aangeeft hoeveel persoon objecten moeten
verzonden worden.\newline
Op basis van dit .proto bestand zullen de nodige klassen gegenereerd worden. Dit gebeurd tijdens het build proces van Gradle door het commando graldew build -x test.
Deze klassen zijn terug te vinden in de folder ''\textbackslash{}build\textbackslash{}classes\textbackslash{}java\textbackslash{}main'' van de entrypoints-grpc module onder application-server,
in het java package be.hogent.nthiers zoals opgegeven met de java\_package optie. De gegenereerde interface People5Grpc moet nu in de applicatie zelf geïmplementeerd worden.
Hier zal de gRPC API functionaliteit gekoppeld worden aan de achterliggende logica met name de GrpcPeopleCache. De 3 methodes die People5Grpc defineert komen overeen met de 3 functies die
in het .proto bestand zijn opgegeven. Hun return value en method variables zijn ook gegenereerde klassen die de messages van het .proto bestand weerspiegelen.
Deze zijn voorzien van builder waarmee we ze kunnen construeren.\newline
Het gRPC API maakt gebruik van de gegenereerde GrpcPerson5 klasse en dus niet dezelfde klasse als REST. Hierdoor wordt er voor het gRPC API een andere cache gebruikt dan
die van het REST API. Indien dezelfde zou gebruikt worden zouden de Person5 objecten gebruikt voor REST voor de gRPC calls steeds naar GrpcPerson5 objecten gemapt moeten worden
wat de performantie mogelijks negatief zou impacteren. Er zou kunnen geopperd worden dat deze omzetten van het domein object naar de gegenereerde klasse bij een gRPC API steeds nodig
zal zijn en er dus ook rekening mee gehouden dient te worden bij het evalueren van de performantie, het is echter ook bij REST best practice om het domein niet rechtstreeks
via een API bloot te stellen, maar daarentegen om te zetten naar zogenaamde data transfer objects.\newline
~\autocite{quarkusgRPC}\\
~\autocite{DTO}\\
~\autocite{gRPCBestPractices}\\
~\autocite{builderPattern}\\

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\linewidth]{gegenereerdeklassengrpc}
    \caption{[Door protoc buffer compiler gegenereerde klassen]Door protoc buffer compiler gegenereerde klassen}
\end{figure}

De server applicatie wordt gedeployed naaar OpenShift van Red Hat. Op OpenShift is HTTP2 en dus ook gRPC connectiviteit steeds met gebruik van TLS protocol.
Gezien het gebruik van TLS bij gRPC ook als best practice gezien wordt, zoals eerder gemeld in de stand van zaken, zal het hier mee onderdeel uitmaken van performantie testen.\newline
~\autocite{openshifttls}

\paragraph{Client applicatie}

De client applicatie zal klassen voorzien die zowel het REST als gRPC API kunnen aanspreken.
Net zoals bij de server applicatie maakt de client applicatie gebruik van Quarkus.\\

Voor de REST client is er interface die bij Quarkus kenbaar gemaakt wordt als REST client door de @RegisterRestClient annotatie. Deze annotatie wordt ook een configKey meegeven
zodat Quarkus weet welke configuratie moet gebruikt worden voor deze client.  Enkel de url en scope properties zijn hierbij nodig waarbij de url slaat op de url van de
REST API die wordt aangesproken en de scope aangeeft welke CDI scope deze client dient te krijgen, in dit geval Singleton.
Verder wordt de interface zelf voorzien van de @Path annotatie met als String value een deel van de url welke
aan alle endpoints gemeen is, meer specifiek /people5. Elke methode die voorzien wordt in de interface staat voor een endpoint dat kan aangesproken worden.
Boven de clearData methode staat een @POST annotatie waarmee wordt aangegeven dat bij deze methode de POST HTTP-method moet gebruikt worden alsook
nog een @Path annotatie met ´''/cleardata'' als value die de url verder specifieert. De people5 methode krijgt een @GET en een @Path annotatie, waarbij die laatste ''/{amount}''
als value heeft. Deze methode heeft ook een parameter amount welke ook voorzien wordt van een @PathParam annotatie met ´amount` als value zodat Quarkus
deze parameter als path parameter zal gebruiken. De derde methode people5Compressed is buiten de naam identiek als de people5 methode. Quarkus zal automatisch de compressie
herkennen en decompresseren naar het originele formaat.
~\autocite{quarkusRESTclient}\\

Voor de gRPC client moet weer een .proto bestand voorzien worden op basis waarvan de protocol buffer compiler de nodige code kan genereren. Gemakkelijkheidshalve wordt het
.proto bestand van de server applicatie hier gewoon gekopieerd. In tegenstelling tot in de server applicatie moet er hier geen interface geïmplementeerd worden maar
is er door de generatie een People5Grpc klasse beschikbaar waarmee het gRPC API van de server kan aangesproken worden. Deze klasse kan door gebruik van de
@GrpcClient annotatie geinjecteerd worden in de service klasse welke de functionaliteit verder implementeerd voor gebruik door de testen. Deze annotatie
kan voorzien worden van een String value element name die door Quarkus zal gebruikt worden om de gRPC client te configureren. In de properties worden enkele properties voorzien
die Quarkus nodig heeft. Quarkus weet dankzij de opgegeven element name welke properties hij voor deze specifieke client moet gebruiken.\newline

\begin{itemize}
    \item ''use-quarkus-grpc-client'' wordt op false gezet zodat de gRPC implementatie gebaseerd op Netty gebruikt wordt. Deze werkt op OpenShift.
    \item ''port'' dient om de poort aan te geven via welke de communicatie met het gRPC API zal gebeuren
    \item ''host'' laat toe de url te defineren van de gRPC server
    \item ''ssl.certificate'' geeft de naam van het SSL certificaat welke zich in de recources folder van de client applicatie bevindt
    \item ''max-inbound-message-size'' wordt gebruikt om de standaard maximum message grootte van 4MB te wijzigen
\end{itemize}

Om de gRPC client People5Grpc aan te spreken moeten dezelfde gegenereerde message klassen gebruikt worden als in de server applicatie.
De clearData en de getPeople methode hebben beiden de wrapper klasse ''io.smallrye.mutiny.Uni'' als return type respectievelijk met de gegenereerde klassen
SupportedAmount en GrpcPeople5, deze laatste bevat een lijst met GrpcPerson5 objecten. De getPeopleStream methode daarentegen geeft een ''io.smallrye.mutiny.Multi'' terug.
Zowel Uni als Multi representeren een stream en zijn asynchrone types. Uni omvat slechts één item of een fout. Multi omvat 0 tot potentieel oneindig veel items.
Voor Uni zal er gewoon op het item gewacht worden tot dit ontvangen is. Voor een Multi zal er gesubscribed worden en zullen er drie functies nodig zijn om
de items te verwerken. De eerste functie, van het type ~\parencite{Consumer}, gaat elk item verwerken, de tweede functie, weer het type ~\parencite{Consumer},
gaat eventuele failures verwerken en de derde functie, van het type ~\parencite{Runnable} wordt aangeroepen wanneer de call voltooid is.\newline

%+++ gRPC Quarkus properties en SSL configuratie uitleg +++
%+++ implementatie van gRPC duurde veel langer door de opzet van de omgeving, bij gRPC is TSL ingebakken in de applicatie en niet enkel een probleem voor de infrastructuur

~\autocite{quarkusgRPCclient}\\
~\autocite{SmallRyeMutiny}\\
~\autocite{MultiSubscribing}\\

De performantie testen worden in dit deel van het project voorzien. De testklasse People5RestServiceTest omvat de performantietesten voor het REST API
en de People5GrpcServiceTest omvat de testen voor het gRPC API. Beiden maken gebruik van een hulpklasse TestHelper de oproepen naar de API's gaat doen,
logs gaat bijhouden en ook het tijdverloop registreren. Voor de constructie van deze hulp klasse moeten drie parameters meegegeven worden nl. een functie
die kan aangeroepen worden om de cache leeg te maken, een object mapper die de objecten naar JSON formaat kan serialiseren en deserialiseren en tot slot de
functie die moet aangeroepen worden om de API calls te doen. Er zijn dan 2 publieke methodes, testPerformance\_singularRequests en testPerformance\_multipleRequests,
die door de testklassen zullen aangeroepen worden. Bij testPerformance\_singularRequests moet de naam van de test meegegeven worden, deze zal bij het wegschrijven
van het logbestand en ook in de logs zelf gebruikt worden, en de lijst van aantallen, in de vorm van een lijst van integers, welke moeten opgevraagd worden
d.m.v. de API call. Eerst wordt de cache eerst leeggemaakt dan wordt de API call tweemaal uitgevoerd zodat de cache voor de specifieke call die getest moet worden
zeker opgevuld is en zodat de server opgewarmd is. Daarna wordt de performantie gestest door de tijd te registreren dan de call nogmaals uit te voeren.
Wanneer het antwoord ontvangen is wordt de tijdsduur vastgelegd. Bij de REST calls wordt de ontvangen lijst van personen nogmaals geserialiseerd naar JSON
en naar een file weggeschreven om zo de grootte van de dataset in JSON formaat te kunnen registreren.
Tot slot gaat de TestHelper ook de logs, met daarin het resultaat van de performantietest, wegschrijven naar een file.
De tweede methode testPerformance\_multipleRequests verwacht ook de testnaam, een lijst van amounts en daarnaast nog een integer genaamd batchSize.
Tijdens het uitvoeren van deze method zullen de opgegeven aantallen opgehaald worden d.m.v. de API call meermaals uit te voeren met de batchSize als aantal
tot het totale gevraagd aantal is ontvangen. Ook hier wordt de tijd geregistreerd, maar dan van het ophalen van het volledige aantal d.m.v.
verschillende calls van de opgegeven batch grootte.\\

De broncode van dit project, dat zowel de server als client applicatie omvat, is publiek beschikbaar op Github via https://github.com/thiersnicolas/gRPC\_vs\_REST.git

\section{Enkelvoudige requests}

Uit de eerdere uitleg over de implementatie van de TestHelper klasse zal al enigzins duidelijk geworden zijn hoe de performantie testen gaan verlopen.
Er wordt gestart met de performantie te evalueren van enkelvoudige requests voor welbepaalde sets van data voor alle geïmplementeerde API calls.
Het doel is vast te leggen hoe de verhouding van het tijdsverloop tussen de verschillende API calls is en hoe deze evolueert naargelang de
datasets groter of kleiner zijn.\\

De API calls die zullen worden uitgevoerd:
\begin{itemize}
    \item REST API: GET people5
    \item REST API
    \item gRPC getPeople
    \item gRPC getPeopleStream
\end{itemize}

Tabel~\ref{tab:Gevraagdedatasets} geeft de datasets weer die opgevraagd zullen worden, hiervoor werd reeds gekeken wat hun grootte is
wanneer ze in JSON formaat naar een bestand worden weggeschreven (deze grootte kan zeer kleine verschillen vertonen welke nagenoeg geen impact zullen hebben op de performantie):\\

\begin{table}
    \centering
    \begin{tabular}{rrll}
        \toprule
        \textbf{Aantal personen} & \textbf{Grootte (bytes)} & \textbf{Grootte (KB)} & \textbf{Grootte (MB)} \\
        \midrule
        1024 & 89028 & 86,94 & 0,08 \\
        2048 & 178062 & 173,89 & 0,17 \\
        4096 & 356103 & 347,76 & 0,34 \\
        8192 & 712225 & 695,53 & 0,68 \\
        9216 & 801209 & 782,43 & 0,76 \\
        10240 & 890124 & 869,26 & 0,85 \\
        11264 & 979136 & 956,19 & 0,93 \\
        12288 & 1068188 & 1043,15 & 1,02 \\
        13312 & 1157125 & 1130 & 1,1 \\
        14336 & 1246294 & 1217,08 & 1,19 \\
        15360 & 1335174 & 1303,88 & 1,27 \\
        16384 & 1424160 & 1390,78 & 1,36 \\
        20480 & 1780317 & 1738,59 & 1,7 \\
        24576 & 2136595 & 2086,52 & 2,04 \\
        28672 & 2492585 & 2434,17 & 2,38 \\
        32768 & 2848302 & 2781,54 & 2,72 \\
        36864 & 3204548 & 3129,44 & 3,06 \\
        40960 & 3560626 & 3477,17 & 3,4 \\
        45056 & 3916542 & 3824,75 & 3,74 \\
        49152 & 4272567 & 4172,43 & 4,07 \\
        53248 & 4628732 & 4520,25 & 4,41 \\
        57344 & 4984625 & 4867,8 & 4,75 \\
        61440 & 5341250 & 5216,06 & 5,09 \\
        65536 & 5697065 & 5563,54 & 5,43 \\
        131072 & 11394036 & 11126,99 & 10,87 \\
        262144 & 22788054 & 22253,96 & 21,73 \\
        524288 & 45575493 & 44507,32 & 43,46 \\
        \bottomrule
    \end{tabular}
    \caption{Gevraagde Datasets}
    \label{tab:Gevraagdedatasets}
\end{table}

Voor de 2 REST calls en de getPeople functie van het gRPC API is het simpelweg bovenstaande lijst door te geven aan de testPerformance\_singularRequests methode
van de TestHelper. De getPeopleStream methode van het gRPC API geeft een object van het type Multi terug, waarover eerder reeds meer informatie werd gegeven.
Om deze methode te testen is er een nieuwe functie gemaakt welke door middel van een AtomicInteger de tel bijhoudt van alle ontvangen items en bij het voltooien van
de gRPC functie een AtomicBoolean op true zet. Wanneer die AtomicBoolean op true staat wordt de controle teruggegeven aan de TestHelper die zo de tijdsduur kan registreren.\\

\section{Meervoudige requests}

In deze volgende onderzoeksfase wordt er meer rekening gehouden met eventuele praktische beperkingen waarmee applicatie kunnen en zullen geconfronteerd worden.
Zo zal het beschikbare geheugen van een applicatie alsook het aantal simultane requests die mogelijks zullen ontvangen worden het noodzakelijk maken om
de toegelaten response grootte te beperken. Voor REST wordt er in dergelijke gevallen vaak voor het pagineren van datasets geopteerd.
Hierbij is de verstuurde dataset slechts een deel van het geheel. De client geeft bij een gepagineerde request aan hoe groot de subset moet zijn
en het hoeveelste deel deze subset is van de gehele dataset. De server geeft de gevraagde subset aangevuld door de subset grootte, de positie t.o.v. de gehele set
en tot slot ook de grootte van de gehele lijst.\\

Praktisch wordt hier de testPerformance\_multipleRequests van de TestHelper klasse aangeroepen voor alle REST API calls en de getPeople functie van het gRPC API.
Het tijdsverloop van alle calls, met de opgegeven batch grootte, tot de gehele dataset ontvangen is, zal worden geregistreed. Eerst zullen verschillende batch groottes
uitgestest worden om te evalueren wat de impact van deze grootte is op de performantie. Een grote batch heeft immers tot gevolg dat er minder calls zullen moeten uitgevoerd worden.
Wanneer er een zicht is op de meest performante batch grootte per API call zullen weer, zoals in de enkelvoudige requests, dataset van vari\"erende grootte opgevraagd
worden om het performantieimpact daarvan te beschouwen.\\

Tabel ~\ref{tab:Batches} geeft aan welke batches zullen worden gebruikt. Het totale aantal items die worden opgevraagd bedraagd 4.194.304 welke een grootte hebben
van 347,68 mb wanneer ze zijn weggeschreven in JSON formaat naar een bestand.\\

\begin{table}
    \centering
    \begin{tabular}{rrrll}
        \toprule
        \textbf{Aantal calls} & \textbf{Items / call} & \textbf{Grootte batch (bytes)} & \textbf{Grootte batch (KB)} & \textbf{Grootte batch (MB)} \\
        \midrule
        4096 & 1024 & 89028 & 86,94 & 0,08 \\
        2048 & 2048 & 178062 & 173,89 & 0,17 \\
        1024 & 4096 & 356103 & 347,76 & 0,34 \\
        512 & 8192 & 712225 & 695,53 & 0,68 \\
        456 & 9216 & 801209 & 782,43 & 0,76 \\
        410 & 10240 & 890124 & 869,26 & 0,85 \\
        373 & 11264 & 979136 & 956,19 & 0,93 \\
        342 & 12288 & 1068188 & 1043,15 & 1,02 \\
        316 & 13312 & 1157125 & 1130 & 1,1 \\
        293 & 14336 & 1246294 & 1217,08 & 1,19 \\
        274 & 15360 & 1335174 & 1303,88 & 1,27 \\
        256 & 16384 & 1424160 & 1390,78 & 1,36 \\
        205 & 20480 & 1780317 & 1738,59 & 1,7 \\
        171 & 24576 & 2136595 & 2086,52 & 2,04 \\
        147 & 28672 & 2492585 & 2434,17 & 2,38 \\
        128 & 32768 & 2848302 & 2781,54 & 2,72 \\
        114 & 36864 & 3204548 & 3129,44 & 3,06 \\
        103 & 40960 & 3560626 & 3477,17 & 3,4 \\
        94 & 45056 & 3916542 & 3824,75 & 3,74 \\
        86 & 49152 & 4272567 & 4172,43 & 4,07 \\
        79 & 53248 & 4628732 & 4520,25 & 4,41 \\
        74 & 57344 & 4984625 & 4867,8 & 4,75 \\
        69 & 61440 & 5341250 & 5216,06 & 5,09 \\
        64 & 65536 & 5697065 & 5563,54 & 5,43 \\
        32 & 131072 & 11394036 & 11126,99 & 10,87 \\
        16 & 262144 & 22788054 & 22253,96 & 21,73 \\
        8 & 524288 & 45575493 & 44507,32 & 43,46 \\
        \bottomrule
    \end{tabular}
    \caption{Batches}
    \label{tab:Batches}
\end{table}

getPeopleStream van het gRPC API is hier weer het vreemde eendje waarbij het pagineren van de calls zinloos is. De server zal immers de beschikbare capaciteit gebruiken
om item per item door te sturen, gebruik makend van de HTTP 2 functionaliteit, zolang de client niet blokkeert. Voor getPeopleStream zal de testPerformance\_singularRequests methode van
de TestHelper klasse gebruikt worden voor de totale grootte die ook bij de andere API calls wordt opgevraagd. Deze performantie kan dan correct vergeleken worden met de andere resultaten.




